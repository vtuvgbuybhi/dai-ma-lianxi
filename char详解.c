#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

我们聊聊为什么-unsigned char 的范围是（0-256）
unsigned char 的范围是（-128-127） -----我们很容易以为signed char的范围是（-127-127）

首先我们要先清楚char类型的大小是2个字节也就是8个比特位

我们先讲讲为什么unsigned char 的范围是（0-256）
一个char类型的大小是8个比特位---  
最高位也就不表示符号


00000000--8个比特位  转换成十进制也就是0
00000001--转换成十进制也就是1
00000010---   2
11111111---256
这个signed char 是很容易理解的（0-256）



那么我们说说为什么signed char (-128-127)
首先我们得知道8位的比特位中最高位表示的就是符号
1   ---- 表示的是负数
0   ---- 表示的是正数

那么01111111--表示的也就是正数127---最高位0符号位表示正数不参与计算

我们现在要知道-128是哪来的首先得知道加法与减法在内存中是怎么计算的
1+1=2
00000001----1的原码
00000001----1的原码
00000010---表示2---加很简单就是原码进行相加

那么减法呢
1-1
我们转换成加法就是--    1 + （-1）进行计算
00000001 --- 1的原码
10000001 --- -1的原码
10000010----这样一相加的结果就是  -2   了----就error了

于是为了可以让计算机中可以有减法的运算---发明了反码
正数的-----原码与反码是相同的---至于为什么--就是这么规定的
负数的-----反码就是符号位不变其它二进制位取反---也是这么规定的

我们现在从新来看看   1+（-1）的计算
00000001  ----1的反码
11111110  ----（-1）的反码
11111111  ----得出来的结果是反码---我们转换成原码再转换成十进制

11111111--转换成原码计算 10000000---转换成十进制也就是   （-0）

这样子我们貌似通过反码解决了计算机减法的问题可是-----0000 0000 也是表示0的
那么（-0）= +0 =0   我们要10000000  还要来表示0不就重复了嘛


问题又来了  为了避免两个0的问题    ---计算机大神们又研究出了  --补码的概念来解决这个问题

正数的----补码反码原码都是相同的
负数的----补码是在反码的基础上加1---得出了反码

我们再来看看（1+（-1））这个减法问题


 00000001 ----1的补码
 11111111 ----1的补码
100000000 -----得出来的是这么一个二进制序列（这个也是表示（-0）的原码）---我们知道char的大小是8个比特位
截出来就是（去掉最高位）  --- 00000000  --- 最高位是0表示正数 --原码反码补码相同
00000000---转换成十进制就是0了  ---也就是表示了0的原码


现在好了我们再来看看
（-0）的原码 1000 0000  补码为 1 0000 0000 由于char是8位   截出来就是 0000 0000
0的补码跟原码都是          0000 0000
虽然补码0都是相同的    但是有两个0   我们就直接规定以原码为 0000 0000 来表示0

我们现在就解决了计算机减法的问题

这样子一来signed char（-127 - 127）都是可以用原码表示了
唯独原码是（1000 0000）没有用上

那么（原码是 1000 0000）用来充当什么了呢



我们假设不限定char类型（也不限定8位比特位的话）
再来看看-128的原码就是 -- 1 1000 0000   9位最高位是符号位
      再算一下它的反码 -- 1 0111 1111
                  补码 -- 1 1000 0000  --这是-128的补码

128的原码 --- 1000 0000和（-0）的原码是不同的
但是在char类型中可以用 1000 0000 表示-128的关键再于char是8位 -- 它把-128的最高位丢弃了，截断后的原码是 1000 0000
和-0的原码就相同了

也就是说  -128丢弃最高位后的原码与 -0 的原码相同了  我们才干用（1000 0000）来表示-128




那么我们就算是拿截断后的 -128和signed char（-127 - 127）的数进行运算也是不会影响结果的
比如（-128）+（-1）




 1000 0000  - -128的补码
 1111 1111  - -1的补码
10111 1111   --得出来的是补码---char取8位（ 0111 1111 ）--转换成十进制就是1，结果不正确（当然啦原本的答案应该是-129不过
也超出了signed char的范围也是不能表示的）


比如-128+127
1000 0000
0111 1111
1111 1111---结果就是-1（转换成十进制）


所以这就是为什么能用原码1000 0000表示-128的原因









































