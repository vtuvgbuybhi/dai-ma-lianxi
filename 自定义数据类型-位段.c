#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//位段
//位段的成员必须是：int   unsigned int    或 signed int  或者char（属于整形家族）类型
//位段成员名后边有一个冒号和一个数字

//位 --->二进制位

//struct S
//{
//	int _a : 2;//  2个比特位就能够表示 0 1 2 3四种数
//	int _b : 5;//  
//	int _c : 10;
//	int _d : 30;
//};
////47个比特位  ---》 6个字节就够了
//
////位段的内存分配
////位段的空间是按照需要4个字节（int）或者1个字节（char）的方式来开辟的
//
//int main()
//{
//	struct S s;
//	printf("%d\n", sizeof(s));//占8个字节
//
//	//内存看了位段成员都是整形--》所以一次开辟内存空间直接开辟32个比特位
//	//   | ―――――――|――――|―――|――|
//	//   e               c        b      d    a
//	//   a-d 占2个字节    d-d 占5个字节   b-c 占10个字节  这边总共占了17个字节 剩下15个字节不够存放30个字节---》在开辟32个字节存放30个字节的整形
//	//剩下的15个字节直接浪费
//
//	//  |――|――――――――――|
//	//  f    g                    h
//	//g-h 存放30个字节
//	//剩下的2个字节直接浪费
//
//	//故总共占了8个字节
//
//	return 0;
//}

//struct S
//{
//	char  a: 3;
//	char  b : 4;
//	char  c : 5;
//	char d : 4;
//};
//int main()
//{
//	struct S s={0};
//	//内存发现位段成员都是char类型  --》 一次开辟1个字节  8个比特位的空间
//
//	//   |----|--|
//	//   a    b  c      --->b-c 占3个比特位 存放char a      a-b 占4个比特位 存放char b   剩下一个比特位浪费
//
//	//不够在开辟1个字节来存放S的位段成员
//	//  |--|-----|
//	//  f  g     h       ---》g-h占5个比特位 存放char c     剩下的3个比特位不够存放d    再开辟1个字节
//
//	//   |---|---|
//	//   j   k   l      ----》k-l占4个比特位存放char d  剩下的4个比特位浪费
//
//	//故s的总大小位3个字节
//
//	s.a = 10;   
//	//a的二进制   000001010
//	s.b = 20;
//	//b    --》 00010100
//	s.c = 3;
//	//c  ----》  000011
//	s.d = 4;
//	//d    ----》 00100
//
//	//将a，b，c，d存放在内存中
//
//	//a---》存放在a的位置   --》但a只占3个比特位 故只存放  010
//
//	//b---》存放在b的位置   --》但b只占4个比特位  故只存放 0100
//
//	//c---》 存放c的位置    ---》 但c占5个比特位  故只存放 00011
//
//	//d---》 存放d的位置    ---》但d占4个比特位  故只存放0100
//
//	//那么在内存中存放的二进制  就是   0010 0010   0000 0011 0000 0100
//	// 内存中存放的二进制                 2   2      0     3    0    4
//	// 打印出来是以十六进制打印  22 03 04
//
//	printf("%d\n", sizeof(s));
//	return 0;
//}


//跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是跨平台性的问题存在














































